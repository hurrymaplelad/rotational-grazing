package aph.rg{	import flash.display.MovieClip;	import flash.geom.Point;	import flash.events.Event;	import flash.events.MouseEvent;	import aph.grids.Grid;	import aph.grids.ParaGrid;	import aph.grids.Tiler;	import aph.grids.GridBox;	import aph.grids.GridPoint;	public class PastureMind extends MovieClip {		private var rows:int;		private var columns:int;		private var grid:Grid;				private var selecting:Boolean;		private var startPt:GridPoint;				private var grazingField:GridBox;		private var selectedField:GridBox;				// grid layers		private var groundLayer:Tiler;		private var backFenceLayer:Tiler;		private var grassLayer:Tiler;		private var frontFenceLayer:Tiler;		private var sheepLayer:Tiler;		/** CONSTRUCTOR **/		public function PastureMind(rows:int, cols:int) {			// define the grid			this.rows=rows;			this.columns=cols;			grid = new ParaGrid(rows,columns,40,20,Math.PI/4);			// add layers			groundLayer=new Tiler(grid);			addChild(groundLayer);			groundLayer.fill(Ground);			grassLayer = new Tiler(grid);			addChild(grassLayer);			grassLayer.fill(Grass);			backFenceLayer = new Tiler(grid);			addChild(backFenceLayer);			sheepLayer = new Tiler(grid);			addChild(sheepLayer);			frontFenceLayer = new Tiler(grid);			addChild(frontFenceLayer);			sheepLayer.setTile(new GridPoint(1,1),Sheep);			sheepLayer.setTile(new GridPoint(1,2),Sheep);			sheepLayer.setTile(new GridPoint(1,3),Sheep);			sheepLayer.setTile(new GridPoint(0,0),Sheep);			sheepLayer.setTile(new GridPoint(2,4),Sheep);			sheepLayer.setTile(new GridPoint(10,10),Sheep);			sheepLayer.setTile(new GridPoint(0,1),Sheep);			sheepLayer.setTile(new GridPoint(5,9),Sheep);			sheepLayer.setTile(new GridPoint(12,10),Sheep);			fenceIn(new GridBox(new GridPoint(2,2),new GridPoint(2,20)));						selecting=false;		}				private function fenceIn(box:GridBox) {			frontFenceLayer.clear();			backFenceLayer.clear();			var i:int;			//Back Left Corner			var gp:GridPoint = new GridPoint(box.top+1,box.left-1);			if (grid.contains(gp)) {				backFenceLayer.setTile(gp,BLCorner);			}			//back			for (i=box.left; i<=box.right; i++) {				gp = new GridPoint(box.top+1,i);				if (grid.contains(gp))					backFenceLayer.setTile(gp,HFence);			}			//Back Right Corner			gp = new GridPoint(box.top+1,box.right+1);			if (grid.contains(gp)) {				backFenceLayer.setTile(gp,BRCorner);			}			//front			for (i=box.left; i<=box.right; i++) {				gp = new GridPoint(box.bottom-1,i);				if (grid.contains(gp))					frontFenceLayer.setTile(gp,HFence);			}			//left			for (i=box.top; i>=box.bottom; i--) {				gp = new GridPoint(i,box.left-1);				if (grid.contains(gp))					backFenceLayer.setTile(gp,VFence);			}			//right			for (i=box.top+1; i>=box.bottom; i--) {				gp = new GridPoint(i,box.right+1);				if (grid.contains(gp))					frontFenceLayer.setTile(gp,VFence);			}			//Front Right Corner 			gp = new GridPoint(box.bottom-1,box.right+1);			if (grid.contains(gp))				frontFenceLayer.setTile(gp,FRCorner);			//Front Left Corner 			gp = new GridPoint(box.bottom-1,box.left-1);			if (grid.contains(gp))				frontFenceLayer.setTile(gp,FLCorner);		}				private function isAvailable(gp:GridPoint):Boolean{			return (grid.contains(gp) &&					sheepLayer.isEmpty(gp) &&					backFenceLayer.isEmpty(gp) &&					frontFenceLayer.isEmpty(gp));		}				public function run():void {			removeEventListener(Event.ENTER_FRAME,enterFrameHandler);			addEventListener(Event.ENTER_FRAME,enterFrameHandler);			removeEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);			addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);			removeEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);			addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);		}				private function enterFrameHandler(event:Event):void {			// redraw fence //			if(selecting){				selectedField = new GridBox(startPt, mouseTile());				fenceIn(selectedField);			}						// loop through every tile on the grid			for (var i:int=0; i<rows; i++) {				for (var j:int=0; j<columns; j++) {					var gp:GridPoint = new GridPoint(i,j);					// grow grass /////					var grass:Grass = grassLayer.getTile(gp) as Grass;					grass.grow();										// move sheep ////					if (!sheepLayer.isEmpty(gp)) {						var sheep:Sheep = sheepLayer.getTile(gp) as Sheep;						if (Math.random()>.92) {							var potentialMoves = new Array();							var bestMoves = new Array();							var bestGrass:Grass = grass;							potentialMoves.push(gp.left);							potentialMoves.push(gp.above);							potentialMoves.push(gp.below);							potentialMoves.push(gp.right);														for each(var tar:GridPoint in potentialMoves){								if(isAvailable(tar)){									var tarGrass:Grass = grassLayer.getTile(tar) as Grass;									if(tarGrass.biomass > bestGrass.biomass){										bestGrass=tarGrass;										bestMoves = new Array(tar);									} else if(tarGrass.biomass == bestGrass.biomass){										bestMoves.push(tar);									}								}							}														if(bestMoves.length>0){								// choose randomly between the best moves								var index:int = Math.floor(Math.random()*bestMoves.length);								var dest:GridPoint = bestMoves[index];								// move sheep there								sheepLayer.remap(gp, dest);								sheep.moveTo(grid.tilePosition(dest));							}						}						grass.kill(2);						sheep.update();					}				}			}		}				private function mouseDownHandler(e:MouseEvent){			startPt=mouseTile();			selecting = true;		}				private function mouseUpHandler(e:MouseEvent){			selecting = false;		}				private function mouseTile():GridPoint {			var p:Point = new Point(this.mouseX, this.mouseY);			return grid.toTile(p);		}		// end of class	}}